/**
 *  Copyright (c) 2025, German Rivera
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 */

#include "cpu_asm.h"

.section .text.reset_handler
.global reset_handler
reset_handler:
    /*
     * Check if we booted at EL2 or at EL1
     *
     * NOTE: Normally we are booted at EL2, but when booted from
     * the UARt boot loader can go back to the UART boot loader at EL1.
     */
    mrs    x0, CurrentEL
    and    x0, x0, #PSTATE_EL_MASK
    cmp    x0, #PSTATE_EL_EL2_MASK
    bne    reset_handler_el1

    msr sctlr_el1, xzr

    /*
     * Set the execution state for EL1 to be AArch64:
     */
    mov x0, #HCR_EL2_RW_MASK
    msr hcr_el2, x0

    /*
     * Transition from EL2 to EL1, by returning from an EL2 exception into EL1.
     * Return to EL1 with all exceptions/interrupts disabled and using SP_EL0 stack pointer.
     */
    mov x0, #(PSTATE_DAIF_MASK | PSTATE_EL_EL1_MASK)
    msr spsr_el2, x0
    adr x0, reset_handler_el1
    msr elr_el2, x0
    eret

reset_handler_el1:
    /*
     * Set pointer to interrupt vector table:
     */
    adrp x0, interrupt_vector_table
    add x0, x0, #:lo12:interrupt_vector_table
    msr vbar_el1, x0

    /*
     * Initialize stack pointer for the current CPU:
     */
    mrs x0, mpidr_el1
    and x0, x0, #MPIDR_EL1_CPU_ID_MASK
    adrp x1, isr_stacks
    add x1, x1, #:lo12:isr_stacks
    mov x2, #GUARDED_ISR_STACK_SIZE_IN_BYTES
    mul x3, x0, x2      // x3 = byte offset of per-cpu stack base
    add x1, x1, x3      // x1 = per-cpu stack base address
    add sp, x1, x2

    cmp x0, #0
#if 0 // TODO: Enable this when multicore support is in place
    bne secondary_cpu_main
#else
    bne park_cpu
#endif

    /*
     * Call main() generated by gnat binder, which will do the elaboration
     * of Ada library-level packages and then invoke the main Ada subprogram
     */
    bl main

    b park_cpu
