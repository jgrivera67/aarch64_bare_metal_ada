/**
 *  Copyright (c) 2025, German Rivera
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 */

#include "cpu_asm.h"

.extern main            // main generated by gnat binder
.extern _ada_app_main   // Ada App_Main subprogram from application code

.section .text.reset_handler
.global reset_handler
reset_handler:
    /*
     * Check if we booted at EL2 or at EL1
     *
     * NOTE: Normally we are booted at EL2, but when booted from the
     * UART bootloader, we are booted at EL1.
     */
    mrs    x0, CurrentEL
    and    x0, x0, #PSTATE_EL_MASK
    cmp    x0, #PSTATE_EL_EL2_MASK
    bne    reset_handler_el1

    /*
     * Initialize SCTLR_EL1 to have MMU and caches disabled:
     */
    msr sctlr_el1, xzr
    isb sy

    /*
     * Set the execution state for EL1 to be AArch64:
     */
    mov x0, #HCR_EL2_RW_MASK
    msr hcr_el2, x0

    /*
     * Transition from EL2 to EL1, by returning from an EL2 exception into EL1.
     * Return to EL1 with all exceptions/interrupts disabled and using SP_EL0 stack pointer.
     */
    mov x0, #(PSTATE_DAIF_MASK | PSTATE_EL_EL1_MASK)
    msr spsr_el2, x0
    adr x0, reset_handler_el1
    msr elr_el2, x0
    eret

reset_handler_el1:
    /*
     * Set pointer to interrupt vector table:
     */
    adrp x0, interrupt_vector_table
    add x0, x0, #:lo12:interrupt_vector_table
    msr vbar_el1, x0

    /*
     * Initialize stack pointer for the current CPU:
     */
    GET_CPU_ID x0       // x0 = CPU id
    adrp x1, isr_stacks
    add x1, x1, #:lo12:isr_stacks
    mov x2, #GUARDED_ISR_STACK_SIZE_IN_BYTES
    mul x3, x0, x2      // x3 = byte offset of per-cpu stack base
    add x1, x1, x3      // x1 = per-cpu stack base address
    add sp, x1, x2

    /*
     * For secondary cores, don't call the gnatbind-generated main,
     * as we don't want package elaboration be done multiple times.
     */
                        // x0 = CPU Id
    cbnz x0, 1f

    /*
     * For the primary core, call main generated by gnatbind, which will do the
     * elaboration of Ada library-level packages and then invoke the main Ada subprogram:
     */
    bl main

    /*
     * We should not return from main, but if we do, just park the CPU:
     */
    bl park_cpu

1:
    /*
     * For secondary cores, call the application's Ada main subprogram directly:
     */
    bl _ada_app_main

    /*
     * We should not return from _ada_app_main, but if we do, just park the CPU:
     */
    bl park_cpu
