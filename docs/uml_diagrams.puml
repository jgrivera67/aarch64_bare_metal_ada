'
' UML diagrams
'
' NOTE: To generate .svg files for the diagrams run 'plantuml -tsvg' on this file.
' To generate .latex files run 'plantuml -tlatex on this file.
' To render the diagrams, run 'plantuml -gui' on this file.
'
' author: German Rivera
'

@startuml arch64_bare_metal_tutorial_road_map
start
fork
  :Setting up Raspberry Pi board for bare-metal development;
fork again
  :Building the GNAT cross-toolchain from sources for bare-metal AArch64;
  :Building a minimal platform-independent Ada Runtime library (RTS);
end fork
:AArch64 bare-metal Ada "Hello world" program;
note right
  To verify that a minimal bare-metal
  program boots and UART output works
end note
:Writing your own UART boot loader for Raspberry Pi bare-metal programs;
note right
  To avoid having to update the SD card
  for every change
end note
:Writing your own bare-metal debug message logger in Ada;
note right
  To avoid always printing verbose debug
  messages to the UART
end note
:AArch64 bare-metal exception handling in Ada;
note right
  - To capture debug information when the bare-metal
    program crashes.
  - To verify that saving/restoring CPU registers
    works, needed for interrupt handling.
end note
:Writing your own self-hosted mini GDB server in Ada;
note right
  To be able to get stack traces and read memory
  when the bare-metal program crashes.
end note
fork
   :AArch64 bare-metal memory protection using the ARMv8-A MMU;
   note right
   - To catch invalid memory accesses
   - Needed to enable caches which is necessary to
      support atomic primitives for multicore
      synchronization.
   end note
   :AArch64 bare-metal multicore in Ada;
fork again
   :AArch64 bare-metal interrupt handling in Ada;
end fork
:AArch64 bare-metal multicore interrupt handling in Ada;
fork
  #white:Write your own AArch64 multicore RTOS kernel in SPARK Ada;
fork again
  #white:Write your own AArch64 multicore separation kernel or hypervisor in SPARK Ada;
end fork
stop
@enduml

@startuml raspberrypi4_boot_sequence
title RaspberryPI 4 Boot Sequence from SD card
actor "Power On Raspberry Pi 4"
"Power On Raspberry Pi 4" -> "ROM" : Boot first-stage bootloader
activate "ROM"
   "ROM" -> "SPI EEPROM" : Boot second-stage bootloader
   activate "SPI EEPROM"
      "SPI EEPROM" -> "SPI EEPROM" : Initialize DRAM
      activate "SPI EEPROM"
      deactivate "SPI EEPROM"
      "SPI EEPROM" -> "start.elf on SD card" : Boot OS bootloader
      note right
         Runs at EL3 exception level
         (secure monitor mode)
      end note
      activate "start.elf on SD card"
         "start.elf on SD card" -> "bare-metal binary on SD card" : Boot AArch64 Bare-meta Ada program to DRAM
         activate "bare-metal binary on SD card"
         note right
            Invoked at EL2 exception level
            (hypervisor mode)
         end note
            "bare-metal binary on SD card" -> "bare-metal binary on SD card" : reset_handler
            activate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : transition to EL1 exception level
               note right
               supervisor mode
               end note
               activate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : main generated by gnatbind
               note right
                  Ada package elaboration
               end note
               activate "bare-metal binary on SD card"
                  "bare-metal binary on SD card" -> "bare-metal binary on SD card" : Ada main subprogram
                  activate "bare-metal binary on SD card"
                  deactivate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
            deactivate "bare-metal binary on SD card"
         deactivate "bare-metal binary on SD card"
      deactivate "start.elf on SD card"
   deactivate "SPI EEPROM"
deactivate "ROM"
@enduml

@startuml raspberrypi5_boot_sequence
title RaspberryPI 5 Boot Sequence from SD card
actor "Power On Raspberry Pi 5"
"Power On Raspberry Pi 5" -> "ROM" : Boot first-stage bootloader
activate "ROM"
   "ROM" -> "SPI EEPROM" : Boot second-stage bootloader
   activate "SPI EEPROM"
      "SPI EEPROM" -> "SPI EEPROM" : Initialize DRAM
      activate "SPI EEPROM"
      deactivate "SPI EEPROM"
      "SPI EEPROM" -> "bl31 image (ATF) on SD card" : Boot OS bootloader
      note right
         Runs at EL3 exception level
         (secure monitor mode)
      end note
      activate "bl31 image (ATF) on SD card"
         "bl31 image (ATF) on SD card" -> "bare-metal binary on SD card" : Boot AArch64 Bare-meta Ada program to DRAM
         activate "bare-metal binary on SD card"
            note right
               Invoked at EL2 exception level
               (hypervisor mode)
            end note
            "bare-metal binary on SD card" -> "bare-metal binary on SD card" : reset_handler
            activate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : transition to EL1 exception level
               note right
               supervisor mode
               end note
               activate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : main generated by gnatbind
               note right
                  Ada package elaboration
               end note
               activate "bare-metal binary on SD card"
                  "bare-metal binary on SD card" -> "bare-metal binary on SD card" : Ada main subprogram
                  activate "bare-metal binary on SD card"
                  deactivate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
            deactivate "bare-metal binary on SD card"
         deactivate "bare-metal binary on SD card"
      deactivate "bl31 image (ATF) on SD card"
   deactivate "SPI EEPROM"
deactivate "ROM"
@enduml

@startuml raspberrypi5_uart_boot_sequence
title RaspberryPI 5 Boot Sequence from UART
actor "Power On Raspberry Pi 5"
"Power On Raspberry Pi 5" -> "ROM" : Boot first-stage bootloader
activate "ROM"
   "ROM" -> "SPI EEPROM" : Boot second-stage bootloader
   activate "SPI EEPROM"
      "SPI EEPROM" -> "SPI EEPROM" : Initialize DRAM
      activate "SPI EEPROM"
      deactivate "SPI EEPROM"
      "SPI EEPROM" -> "bl31 image (ATF) on SD card" : Boot OS bootloader
      note right
         Runs at EL3 exception level
         (secure monitor mode)
      end note
      activate "bl31 image (ATF) on SD card"
         "bl31 image (ATF) on SD card" -> "bare-metal binary on SD card" : Boot AArch64 Bare-meta Ada program to DRAM
         activate "bare-metal binary on SD card"
            note right
               Invoked at EL2 exception level
               (hypervisor mode)
            end note
            "bare-metal binary on SD card" -> "bare-metal binary on SD card" : reset_handler
            activate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : transition to EL1 exception level
               note right
               supervisor mode
               end note
               activate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : main generated by gnatbind
               note right
                  Ada package elaboration
               end note
               activate "bare-metal binary on SD card"
                  "bare-metal binary on SD card" -> "bare-metal binary on SD card" : Ada main subprogram
                  activate "bare-metal binary on SD card"
                  deactivate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
            deactivate "bare-metal binary on SD card"
         deactivate "bare-metal binary on SD card"
      deactivate "bl31 image (ATF) on SD card"
   deactivate "SPI EEPROM"
deactivate "ROM"
@enduml

@startuml raspberrypi_uart_boot_sequence
title RaspberryPI Boot Sequence from UART
actor "UART bootloader server on SD card"
"UART bootloader server on SD card" -> Uart_Boot_Loader_Server : Load_Image_Over_Uart
activate Uart_Boot_Loader_Server
   Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : Receive_File
   activate Uart_Boot_Loader_Server
      Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : File reception start handshake
      activate Uart_Boot_Loader_Server
         Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : Wait for ASCII.EOT
         actor "picocom terminal emulator"
         "picocom terminal emulator" -> "UART bootloader client on host" : execute
         "UART bootloader client on host" -> Uart_Boot_Loader_Client : Send_File
         activate Uart_Boot_Loader_Client
            Uart_Boot_Loader_Client -> Uart_Boot_Loader_Client : File_Transmission_Start_Handshake
            activate Uart_Boot_Loader_Client
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : ASCII.EOT
               Uart_Boot_Loader_Server -> Uart_Boot_Loader_Client : ASCII.NAK
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : ASCII.EOT
               Uart_Boot_Loader_Server -> Uart_Boot_Loader_Client : ASCII.ACK
            deactivate Uart_Boot_Loader_Client
         deactivate Uart_Boot_Loader_Client
      deactivate Uart_Boot_Loader_Client

      loop
         Uart_Boot_Loader_Client -> Uart_Boot_Loader_Client : "Transmit packet"
         activate Uart_Boot_Loader_Client
            Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : "Receive packet"
            activate Uart_Boot_Loader_Server
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : ASCII.STX
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : 8-bit packet number
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : Negated 8-bit packet number
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : 1K packet data
               note right
                  filled with ASCII.SUB characters
                  if data length < 1K
               end note
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : 32-bit checksum
               note right
                  transmitted in little-endian
                  (lowest byte first)
               end note
               Uart_Boot_Loader_Server -> Uart_Boot_Loader_Client : ASCII.ACK
               Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : Increment Rx packet number
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Client : Increment Tx packet number
            deactivate Uart_Boot_Loader_Server
         deactivate Uart_Boot_Loader_Client
      end loop

      activate Uart_Boot_Loader_Client
         Uart_Boot_Loader_Client -> Uart_Boot_Loader_Client : File_Transmission_End_Handshake
         activate Uart_Boot_Loader_Client
            Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : ASCII.EOT
            activate Uart_Boot_Loader_Server
               Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : File reception end handshake
               activate Uart_Boot_Loader_Server
                  Uart_Boot_Loader_Server -> Uart_Boot_Loader_Client : ASCII.ACK
                  Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : ASCII.EOT
                  Uart_Boot_Loader_Server -> Uart_Boot_Loader_Client : ASCII.ACK
               deactivate Uart_Boot_Loader_Server
            deactivate Uart_Boot_Loader_Server
         deactivate Uart_Boot_Loader_Client
      deactivate Uart_Boot_Loader_Client
   deactivate Uart_Boot_Loader_Server

   Uart_Boot_Loader_Server -> "bare-metal binary loaded over UART" : reset_handler
   activate "bare-metal binary loaded over UART"
      note right
      Invoked at EL1 exception level
      (supervisor mode)
      end note
      "bare-metal binary loaded over UART" -> "bare-metal binary loaded over UART" : main generated by gnatbind
      note right
      Ada package elaboration
      end note
      activate "bare-metal binary loaded over UART"
        "bare-metal binary loaded over UART" -> "bare-metal binary loaded over UART" : Ada main subprogram
         activate "bare-metal binary loaded over UART"
         deactivate "bare-metal binary loaded over UART"
   deactivate "bare-metal binary loaded over UART"
deactivate Uart_Boot_Loader_Server
@enduml

@startuml entering-gdbserver-on-prefetch-abort
title Entering Self-hosted GDB server on Prefetch Abort
actor "prefetch abort exception"
"prefetch abort exception" -> "interrupt_handling_asm.S" : same_el_with_sp_el0_synchronous_exception_handler
activate "interrupt_handling_asm.S"
   "interrupt_handling_asm.S" ->  "interrupt_handling_asm.S" : INTERRUPT_HANDLER_PROLOG
   activate "interrupt_handling_asm.S"
   deactivate "interrupt_handling_asm.S"
   "interrupt_handling_asm.S" ->  "CPU.Interrupt_Handling" : Ada_Handle_EL1_Synchronous_Exception
   activate "CPU.Interrupt_Handling"
      "CPU.Interrupt_Handling" -> "CPU.Interrupt_Handling" : error_exception_handler()
      activate "CPU.Interrupt_Handling"
      deactivate "CPU.Interrupt_Handling"
      "arch-support.c" ->  "gdbserver.c" : run_gdb_server()
      activate "gdbserver.c"
      deactivate "gdbserver.c"
    deactivate "arch-support.c"
  deactivate "arch-support.c"
deactivate "arch-support-asm.S"
@enduml

@startuml entering-gdbserver-on-data-abort
title Entering Self-hosted GDB server on Data Abort
actor "data abort exception"
"data abort exception" -> "arch-support-asm.S" : data_abort_handler()
activate "arch-support-asm.S"
  "arch-support-asm.S" ->  "arch-support.c" : c_data_abort_handler()
  activate "arch-support.c"
    "arch-support.c" ->  "arch-support.c" : error_exception_handler()
    activate "arch-support.c"
      "arch-support.c" ->  "gdbserver.c" : run_gdb_server()
      note right
        called via g_fault_exception_callback_p()
        function pointer
      end note
      activate "gdbserver.c"
      deactivate "gdbserver.c"
    deactivate "arch-support.c"
  deactivate "arch-support.c"
deactivate "arch-support-asm.S"
@enduml
