'
' UML diagrams
'
' NOTE: To generate .svg files for the diagrams run 'plantuml -tsvg' on this file.
' To generate .latex files run 'plantuml -tlatex on this file.
' To render the diagrams, run 'plantuml -gui' on this file.
'
' author: German Rivera
'

@startuml arch64_bare_metal_tutorial_road_map
start
fork
  :Setting up Raspberry Pi board for bare-metal development;
fork again
  :Building the GNAT cross-toolchain from sources for bare-metal AArch64;
  :Building a minimal platform-independent Ada Runtime library (RTS);
end fork
:AArch64 bare-metal Ada "Hello world" program;
note right
  To verify that a minimal bare-metal
  program boots and UART output works
end note
:Writing your own UART boot loader for Raspberry Pi bare-metal programs;
note right
  To avoid having to update the SD card
  for every change
end note
:Writing your own bare-metal debug message logger in Ada;
note right
  To avoid always printing verbose debug
  messages to the UART
end note
:AArch64 bare-metal exception handling in Ada;
note right
  - To capture debug information when the bare-metal
    program crashes.
  - To verify that saving/restoring CPU registers
    works, needed for interrupt handling.
end note
:Writing your own self-hosted mini GDB server in Ada;
note right
  To be able to get stack traces and read memory
  when the bare-metal program crashes.
end note
fork
   :AArch64 bare-metal memory protection using the ARMv8-A MMU;
   note right
   - To catch invalid memory accesses
   - Needed to enable caches which is necessary to
      support atomic primitives for multicore
      synchronization.
   end note
   :AArch64 bare-metal multicore in Ada;
fork again
   :AArch64 bare-metal interrupt handling in Ada;
end fork
:AArch64 bare-metal multicore interrupt handling in Ada;
fork
  #white:Write your own AArch64 multicore RTOS kernel in SPARK Ada;
fork again
  #white:Write your own AArch64 multicore separation kernel or hypervisor in SPARK Ada;
end fork
stop
@enduml

@startuml raspberrypi4_boot_sequence
title RaspberryPI 4 Boot Sequence from SD card
actor "Power On Raspberry Pi 4"
"Power On Raspberry Pi 4" -> "ROM" : Boot first-stage bootloader
activate "ROM"
   "ROM" -> "SPI EEPROM" : Boot second-stage bootloader
   activate "SPI EEPROM"
      "SPI EEPROM" -> "SPI EEPROM" : Initialize DRAM
      activate "SPI EEPROM"
      deactivate "SPI EEPROM"
      "SPI EEPROM" -> "start.elf on SD card" : Boot OS bootloader
      note right
         Runs at EL3 exception level
         (secure monitor mode)
      end note
      activate "start.elf on SD card"
         "start.elf on SD card" -> "bare-metal binary on SD card" : Boot AArch64 Bare-meta Ada program to DRAM
         activate "bare-metal binary on SD card"
         note right
            Invoked at EL2 exception level
            (hypervisor mode)
         end note
            "bare-metal binary on SD card" -> "bare-metal binary on SD card" : reset_handler
            activate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : transition to EL1 exception level
               note right
               supervisor mode
               end note
               activate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : main generated by gnatbind
               note right
                  Ada package elaboration
               end note
               activate "bare-metal binary on SD card"
                  "bare-metal binary on SD card" -> "bare-metal binary on SD card" : Ada main subprogram
                  activate "bare-metal binary on SD card"
                  deactivate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
            deactivate "bare-metal binary on SD card"
         deactivate "bare-metal binary on SD card"
      deactivate "start.elf on SD card"
   deactivate "SPI EEPROM"
deactivate "ROM"
@enduml

@startuml raspberrypi5_boot_sequence
title RaspberryPI 5 Boot Sequence from SD card
actor "Power On Raspberry Pi 5"
"Power On Raspberry Pi 5" -> "ROM" : Boot first-stage bootloader
activate "ROM"
   "ROM" -> "SPI EEPROM" : Boot second-stage bootloader
   activate "SPI EEPROM"
      "SPI EEPROM" -> "SPI EEPROM" : Initialize DRAM
      activate "SPI EEPROM"
      deactivate "SPI EEPROM"
      "SPI EEPROM" -> "bl31 image (ATF) on SD card" : Boot OS bootloader
      note right
         Runs at EL3 exception level
         (secure monitor mode)
      end note
      activate "bl31 image (ATF) on SD card"
         "bl31 image (ATF) on SD card" -> "bare-metal binary on SD card" : Boot AArch64 Bare-meta Ada program to DRAM
         activate "bare-metal binary on SD card"
            note right
               Invoked at EL2 exception level
               (hypervisor mode)
            end note
            "bare-metal binary on SD card" -> "bare-metal binary on SD card" : reset_handler
            activate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : transition to EL1 exception level
               note right
               supervisor mode
               end note
               activate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : main generated by gnatbind
               note right
                  Ada package elaboration
               end note
               activate "bare-metal binary on SD card"
                  "bare-metal binary on SD card" -> "bare-metal binary on SD card" : Ada main subprogram
                  activate "bare-metal binary on SD card"
                  deactivate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
            deactivate "bare-metal binary on SD card"
         deactivate "bare-metal binary on SD card"
      deactivate "bl31 image (ATF) on SD card"
   deactivate "SPI EEPROM"
deactivate "ROM"
@enduml

@startuml raspberrypi5_uart_boot_sequence
title RaspberryPI 5 Boot Sequence from UART
actor "Power On Raspberry Pi 5"
"Power On Raspberry Pi 5" -> "ROM" : Boot first-stage bootloader
activate "ROM"
   "ROM" -> "SPI EEPROM" : Boot second-stage bootloader
   activate "SPI EEPROM"
      "SPI EEPROM" -> "SPI EEPROM" : Initialize DRAM
      activate "SPI EEPROM"
      deactivate "SPI EEPROM"
      "SPI EEPROM" -> "bl31 image (ATF) on SD card" : Boot OS bootloader
      note right
         Runs at EL3 exception level
         (secure monitor mode)
      end note
      activate "bl31 image (ATF) on SD card"
         "bl31 image (ATF) on SD card" -> "bare-metal binary on SD card" : Boot AArch64 Bare-meta Ada program to DRAM
         activate "bare-metal binary on SD card"
            note right
               Invoked at EL2 exception level
               (hypervisor mode)
            end note
            "bare-metal binary on SD card" -> "bare-metal binary on SD card" : reset_handler
            activate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : transition to EL1 exception level
               note right
               supervisor mode
               end note
               activate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
               "bare-metal binary on SD card" -> "bare-metal binary on SD card" : main generated by gnatbind
               note right
                  Ada package elaboration
               end note
               activate "bare-metal binary on SD card"
                  "bare-metal binary on SD card" -> "bare-metal binary on SD card" : Ada main subprogram
                  activate "bare-metal binary on SD card"
                  deactivate "bare-metal binary on SD card"
               deactivate "bare-metal binary on SD card"
            deactivate "bare-metal binary on SD card"
         deactivate "bare-metal binary on SD card"
      deactivate "bl31 image (ATF) on SD card"
   deactivate "SPI EEPROM"
deactivate "ROM"
@enduml

@startuml raspberrypi_uart_boot_sequence
title RaspberryPI Boot Sequence from UART
actor "UART bootloader server on SD card"
"UART bootloader server on SD card" -> Uart_Boot_Loader_Server : Load_Image_Over_Uart
activate Uart_Boot_Loader_Server
   Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : Receive_File
   activate Uart_Boot_Loader_Server
      Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : File reception start handshake
      activate Uart_Boot_Loader_Server
         Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : Wait for ASCII.EOT
         actor "picocom terminal emulator"
         "picocom terminal emulator" -> "UART bootloader client on host" : execute
         "UART bootloader client on host" -> Uart_Boot_Loader_Client : Send_File
         activate Uart_Boot_Loader_Client
            Uart_Boot_Loader_Client -> Uart_Boot_Loader_Client : File_Transmission_Start_Handshake
            activate Uart_Boot_Loader_Client
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : ASCII.EOT
               Uart_Boot_Loader_Server -> Uart_Boot_Loader_Client : ASCII.NAK
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : ASCII.EOT
               Uart_Boot_Loader_Server -> Uart_Boot_Loader_Client : ASCII.ACK
            deactivate Uart_Boot_Loader_Client
         deactivate Uart_Boot_Loader_Client
      deactivate Uart_Boot_Loader_Client

      loop
         Uart_Boot_Loader_Client -> Uart_Boot_Loader_Client : "Transmit packet"
         activate Uart_Boot_Loader_Client
            Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : "Receive packet"
            activate Uart_Boot_Loader_Server
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : ASCII.STX
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : 8-bit packet number
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : Negated 8-bit packet number
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : 1K packet data
               note right
                  filled with ASCII.SUB characters
                  if data length < 1K
               end note
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : 32-bit checksum
               note right
                  transmitted in little-endian
                  (lowest byte first)
               end note
               Uart_Boot_Loader_Server -> Uart_Boot_Loader_Client : ASCII.ACK
               Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : Increment Rx packet number
               Uart_Boot_Loader_Client -> Uart_Boot_Loader_Client : Increment Tx packet number
            deactivate Uart_Boot_Loader_Server
         deactivate Uart_Boot_Loader_Client
      end loop

      activate Uart_Boot_Loader_Client
         Uart_Boot_Loader_Client -> Uart_Boot_Loader_Client : File_Transmission_End_Handshake
         activate Uart_Boot_Loader_Client
            Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : ASCII.EOT
            activate Uart_Boot_Loader_Server
               Uart_Boot_Loader_Server -> Uart_Boot_Loader_Server : File reception end handshake
               activate Uart_Boot_Loader_Server
                  Uart_Boot_Loader_Server -> Uart_Boot_Loader_Client : ASCII.ACK
                  Uart_Boot_Loader_Client -> Uart_Boot_Loader_Server : ASCII.EOT
                  Uart_Boot_Loader_Server -> Uart_Boot_Loader_Client : ASCII.ACK
               deactivate Uart_Boot_Loader_Server
            deactivate Uart_Boot_Loader_Server
         deactivate Uart_Boot_Loader_Client
      deactivate Uart_Boot_Loader_Client
   deactivate Uart_Boot_Loader_Server

   Uart_Boot_Loader_Server -> "bare-metal binary loaded over UART" : reset_handler
   activate "bare-metal binary loaded over UART"
      note right
      Invoked at EL1 exception level
      (supervisor mode)
      end note
      "bare-metal binary loaded over UART" -> "bare-metal binary loaded over UART" : main generated by gnatbind
      note right
      Ada package elaboration
      end note
      activate "bare-metal binary loaded over UART"
        "bare-metal binary loaded over UART" -> "bare-metal binary loaded over UART" : Ada main subprogram
         activate "bare-metal binary loaded over UART"
         deactivate "bare-metal binary loaded over UART"
   deactivate "bare-metal binary loaded over UART"
deactivate Uart_Boot_Loader_Server
@enduml

@startuml synchronous-hardware-exception
title Synchronous Hardware Exception
actor "synchronous hardware exception"
activate "synchronous hardware exception"
   "synchronous hardware exception" -> "interrupt_handling_Asm.S" : same_el_with_sp_el0_synchronous_exception_handler
   activate "interrupt_handling_Asm.S"
      "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : INTERRUPT_HANDLER_PROLOG
      activate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : save CPU registers
         activate "interrupt_handling_Asm.S"
         deactivate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Enter_Interrupt_Context
         activate  "CPU.Interrupt_Handling"
         deactivate  "CPU.Interrupt_Handling"
      deactivate "interrupt_handling_Asm.S"

      "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Handle_EL1_Synchronous_Exception
      activate  "CPU.Interrupt_Handling"
         alt data abort or prefetch abort exceptions
            "CPU.Interrupt_Handling" -> "CPU.Interrupt_Handling" : Handle_El1_Error_Exception
            activate  "CPU.Interrupt_Handling"
               "CPU.Interrupt_Handling" -> "CPU.Interrupt_Handling" : Print_Exception_Info
               activate  "CPU.Interrupt_Handling"
               deactivate  "CPU.Interrupt_Handling"
               "CPU.Interrupt_Handling" -> "CPU.Self_Hosted_Debug" : Run_Debugger
               activate  "CPU.Self_Hosted_Debug"
               deactivate  "CPU.Self_Hosted_Debug"
               "CPU.Interrupt_Handling" -> "Utils" : System_Crash
               activate "Utils"
                  "Utils" -> "cpu_asm.S" : Park_Cpu
                  activate "cpu_asm.S"
                  deactivate "cpu_asm.S"
               deactivate "Utils"
            deactivate  "CPU.Interrupt_Handling"
         else breakpoint or watchpoint or break instruction exceptions
            "CPU.Interrupt_Handling" -> "CPU.Interrupt_Handling" : Handle_El1_Debug_Exception
            activate  "CPU.Interrupt_Handling"
               "CPU.Interrupt_Handling" -> "CPU.Interrupt_Handling" : Print_Exception_Info
               activate  "CPU.Interrupt_Handling"
                  "Utils" -> "Utils.Runtime_Log" : Log_Error_*
                  note right
                     Print hardware exception
                     error message to UART
                  end note
                  activate "Utils.Runtime_Log"
                  deactivate "Utils.Runtime_Log"
               deactivate  "CPU.Interrupt_Handling"
               "CPU.Interrupt_Handling" -> "CPU.Self_Hosted_Debug" : Run_Debugger
               activate  "CPU.Self_Hosted_Debug"
               deactivate  "CPU.Self_Hosted_Debug"
            deactivate  "CPU.Interrupt_Handling"
         end alt
      deactivate  "CPU.Interrupt_Handling"

      "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : INTERRUPT_HANDLER_EPILOG
      activate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Exit_Interrupt_Context
         activate  "CPU.Interrupt_Handling"
         deactivate  "CPU.Interrupt_Handling"
         "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : restore CPU registers
         activate "interrupt_handling_Asm.S"
         deactivate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "synchronous hardware exception" : eret
      deactivate "interrupt_handling_Asm.S"
   deactivate "interrupt_handling_Asm.S"
deactivate "synchronous hardware exception"
@enduml

@startuml ada-exception
title Ada Excception
actor "bare-metal Ada program"
"bare-metal Ada program" -> "bare-metal Ada program": Ada exception
activate "bare-metal Ada program"
   "bare-metal Ada program" -> "Utils" : Last_Chance_Handler
   activate "Utils"
      "Utils" -> "Utils.Runtime_Log" : Log_Error_*
      note right
         Print Ada exception error message to UART
      end note
      activate "Utils.Runtime_Log"
      deactivate "Utils.Runtime_Log"
      actor "CPU core"
      "Utils" -> "CPU core" : BRK instruction
      note right
      Synchronous hardware exception
      end note
      activate "CPU core"
         "CPU core" -> "interrupt_handling_Asm.S" : same_el_with_sp_el0_synchronous_exception_handler
         activate "interrupt_handling_Asm.S"
            "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Handle_EL1_Synchronous_Exception
            activate  "CPU.Interrupt_Handling"
               "CPU.Interrupt_Handling" -> "CPU.Interrupt_Handling" : Handle_El1_Debug_Exception
               activate  "CPU.Interrupt_Handling"
                  "CPU.Interrupt_Handling" -> "CPU.Self_Hosted_Debug" : Run_Debugger
                  activate  "CPU.Self_Hosted_Debug"
                  deactivate  "CPU.Self_Hosted_Debug"
               deactivate  "CPU.Interrupt_Handling"
            deactivate  "CPU.Interrupt_Handling"
            "interrupt_handling_Asm.S" -> "Utils" : eret
         deactivate "interrupt_handling_Asm.S"
      deactivate "CPU core"
      "Utils" -> "Utils" : Systen_Crash
      activate "Utils"
         "Utils" -> "cpu_asm.S" : Park_Cpu
         activate "cpu_asm.S"
         deactivate "cpu_asm.S"
      deactivate "Utils"
   deactivate "Utils"
deactivate "bare-metal Ada program"
@enduml

@startuml enetering-self-hosted-debugger-on-synchronous-exception
title Entering Self-hosted debugger on synchronous hardware exception
actor "synchronous hardware exception"
activate "synchronous hardware exception"
   "synchronous hardware exception" -> "interrupt_handling_Asm.S" : same_el_with_sp_el0_synchronous_exception_handler
   activate "interrupt_handling_Asm.S"
      "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : INTERRUPT_HANDLER_PROLOG
      activate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : save CPU registers
         activate "interrupt_handling_Asm.S"
         deactivate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Enter_Interrupt_Context
         activate  "CPU.Interrupt_Handling"
         deactivate  "CPU.Interrupt_Handling"
      deactivate "interrupt_handling_Asm.S"

      "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Handle_EL1_Synchronous_Exception
      activate  "CPU.Interrupt_Handling"
         alt data abort or prefetch abort exceptions
            "CPU.Interrupt_Handling" -> "CPU.Interrupt_Handling" : Handle_El1_Error_Exception
            activate  "CPU.Interrupt_Handling"
               "CPU.Interrupt_Handling" -> "CPU.Interrupt_Handling" : Print_Exception_Info
               activate  "CPU.Interrupt_Handling"
               deactivate  "CPU.Interrupt_Handling"
               "CPU.Interrupt_Handling" -> "CPU.Self_Hosted_Debug" : Run_Debugger
               activate  "CPU.Self_Hosted_Debug"
                  "CPU.Self_Hosted_Debug" -> "Gdb_Server" : Run_Gdb_Server
                  activate  "Gdb_Server"
                  deactivate  "Gdb_Server"
               deactivate  "CPU.Self_Hosted_Debug"
               "CPU.Interrupt_Handling" -> "Utils" : System_Crash
               activate "Utils"
                  "Utils" -> "cpu_asm.S" : Park_Cpu
                  activate "cpu_asm.S"
                  deactivate "cpu_asm.S"
               deactivate "Utils"
            deactivate  "CPU.Interrupt_Handling"
         else breakpoint or watchpoint or break instruction exceptions
            "CPU.Interrupt_Handling" -> "CPU.Interrupt_Handling" : Handle_El1_Debug_Exception
            activate  "CPU.Interrupt_Handling"
               "CPU.Interrupt_Handling" -> "CPU.Interrupt_Handling" : Print_Exception_Info
               activate  "CPU.Interrupt_Handling"
                  "Utils" -> "Utils.Runtime_Log" : Log_Error_*
                  note right
                     Print hardware exception
                     error message to UART
                  end note
                  activate "Utils.Runtime_Log"
                  deactivate "Utils.Runtime_Log"
               deactivate  "CPU.Interrupt_Handling"
               "CPU.Interrupt_Handling" -> "CPU.Self_Hosted_Debug" : Run_Debugger
               activate  "CPU.Self_Hosted_Debug"
                  "CPU.Self_Hosted_Debug" -> "Gdb_Server" : Run_Gdb_Server
                  activate  "Gdb_Server"
                  deactivate  "Gdb_Server"
               deactivate  "CPU.Self_Hosted_Debug"
            deactivate  "CPU.Interrupt_Handling"
         end alt
      deactivate  "CPU.Interrupt_Handling"

      "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : INTERRUPT_HANDLER_EPILOG
      activate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Exit_Interrupt_Context
         activate  "CPU.Interrupt_Handling"
         deactivate  "CPU.Interrupt_Handling"
         "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : restore CPU registers
         activate "interrupt_handling_Asm.S"
         deactivate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "synchronous hardware exception" : eret
      deactivate "interrupt_handling_Asm.S"
   deactivate "interrupt_handling_Asm.S"
deactivate "synchronous hardware exception"
@enduml

@startuml load~instruction-memory-access-with-mmu-and-caches
title Memory access from a load instruction with MMU and caches enables
actor "CPU core"
"CPU core" -> "CPU core" : load instruction
activate "CPU core"
"CPU core" -> "TLB" : VA-to-PA translation lookup
   alt TLB hit
      "TLB" -> "CPU core" : VA-to-PA translation entry
      alt access allowed
         "CPU core" -> "Caches" : data lookup
         "Caches" -> "Caches" : L1 data cache lookup
            alt L1 data cache hit
               "Caches" -> "CPU core" : data
            else
               "Caches" -> "Caches" : L2 cache lookup
               alt L2 cache hit
                  "Caches" -> "CPU core" : data
               else
                  "Caches" -> "Caches" : L3 cache lookup
                  alt L3 cache hit
                     "Caches" -> "CPU core" : data
                  else cache miss
                     "Caches" -> "CPU core" : cache miss
                     "CPU core" -> "Physical Memory" : read cache line
                     "Physical Memory" -> "Caches" : allocate and fill cache line
                     "Physical Memory" -> "CPU core" : data
                  end alt
               end alt
            end alt
         alt Cache hit
         end alt
      else access not allowed
         "CPU core" -> "CPU core" : Ttrigger data abort excpetion
      end alt
   else TLB miss
      "TLB" -> "CPU core" : TLB miss
      actor "MMU page table\nwalker"
      "CPU core" -> "MMU page table\nwalker" : VA-to-PA translation lookup
         alt valid translation entry found
            "MMU page table\nwalker" -> TLB : VA-to-PA translation entry
            "MMU page table\nwalker" -> "CPU core" : VA-to-PA translation entry
         else page fault
            "MMU page table\nwalker" -> "CPU core" : page fault
            "CPU core" -> "CPU core" : trigger data abort exception
         end alt
   end alt
deactivate "CPU core"
@enduml

@startuml timer-interrupt-handling
title Timer Interrupt Handling
actor "Generic Timer perihperal"
"Generic Timer perihperal" -> "GIC 400\nInterrupt Controller" : PPI interrupt
note right
Private Peripheral Interrupt
end note
"GIC 400\nInterrupt Controller" -> "CPU core" : IRQ interrupt
   "CPU core" -> "interrupt_handling_Asm.S" : same_el_with_sp_el0_irq_interrupt_handler
   activate "interrupt_handling_Asm.S"
      "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : INTERRUPT_HANDLER_PROLOG
      activate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : save CPU registers
         activate "interrupt_handling_Asm.S"
         deactivate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Enter_Interrupt_Context
         activate  "CPU.Interrupt_Handling"
         deactivate  "CPU.Interrupt_Handling"
      deactivate "interrupt_handling_Asm.S"

      "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Handle_EL1_Irq_Interrupt
      activate  "CPU.Interrupt_Handling"
         "CPU.Interrupt_Handling" -> "Interrupt_Controller_Driver" : GIC_Interrupt_Handler (Cpu_Interrupt_Irq)
         activate  "Interrupt_Controller_Driver"
            "Interrupt_Controller_Driver" -> "GIC 400\nInterrupt Controller" : Read GICC.ICC_IAR register
            note right
            Notifiy the interrutpt controller that
            handling of the interrupt has started
            (Interrupt Acknowledgement)
            end note
            "Interrupt_Controller_Driver" -> "CPU.Interrupt_Handling" : Enable_Cpu_Interrupting
            note right
            Enable interrupts at the CPU to
            support nested interrupts
            end note
            activate  "CPU.Interrupt_Handling"
            deactivate  "CPU.Interrupt_Handling"
            "Interrupt_Controller_Driver" -> "Timer_Driver" : Timer_Interrupt_Handler
            activate  "Timer_Driver"
               "Timer_Driver" -> "Application" : Timer interrupt callback
               activate  "Application"
               deactivate  "Application"
            deactivate  "Timer_Driver"
            "Interrupt_Controller_Driver" -> "CPU.Interrupt_Handling" : Disable_Cpu_Interrupting
            activate  "CPU.Interrupt_Handling"
            deactivate  "CPU.Interrupt_Handling"
            "Interrupt_Controller_Driver" -> "GIC 400\nInterrupt Controller" : Write GICC.ICC_EOIR register
            note right
            Notify the interrupt controller that handling
            for the interrupt has been completed.
            (End of Interrupt)
            end note
         deactivate  "Interrupt_Controller_Driver"
      deactivate  "CPU.Interrupt_Handling"

      "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : INTERRUPT_HANDLER_EPILOG
      activate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Exit_Interrupt_Context
         activate  "CPU.Interrupt_Handling"
         deactivate  "CPU.Interrupt_Handling"
         "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : restore CPU registers
         activate "interrupt_handling_Asm.S"
         deactivate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : eret
         note right
            Return to interrupted codde
         end note
      deactivate "interrupt_handling_Asm.S"
   deactivate "interrupt_handling_Asm.S"
@enduml

@startuml UART-interrupt-handling
title UART Rx Interrupt Handling
actor "UART perihperal"
"UART perihperal" -> "GIC 400\nInterrupt Controller" : SPI interrupt
note right
Shared Peripheral Interrupt
(routed to configured target CPU)
end note
"GIC 400\nInterrupt Controller" -> "CPU core" : IRQ interrupt
   "CPU core" -> "interrupt_handling_Asm.S" : same_el_with_sp_el0_irq_interrupt_handler
   activate "interrupt_handling_Asm.S"
      "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : INTERRUPT_HANDLER_PROLOG
      activate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : save CPU registers
         activate "interrupt_handling_Asm.S"
         deactivate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Enter_Interrupt_Context
         activate  "CPU.Interrupt_Handling"
         deactivate  "CPU.Interrupt_Handling"
      deactivate "interrupt_handling_Asm.S"

      "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Handle_EL1_Irq_Interrupt
      activate  "CPU.Interrupt_Handling"
         "CPU.Interrupt_Handling" -> "Interrupt_Controller_Driver" : GIC_Interrupt_Handler (Cpu_Interrupt_Irq)
         activate  "Interrupt_Controller_Driver"
            "Interrupt_Controller_Driver" -> "GIC 400\nInterrupt Controller" : Read GICC.ICC_IAR register
            note right
            Notifiy the interrutpt controller that
            handling of the interrupt has started
            (Interrupt Acknowledgement)
            end note
            "Interrupt_Controller_Driver" -> "CPU.Interrupt_Handling" : Enable_Cpu_Interrupting
            note right
            Enable interrupts at the CPU to
            support nested interrupts
            end note
            activate  "CPU.Interrupt_Handling"
            deactivate  "CPU.Interrupt_Handling"
            "Interrupt_Controller_Driver" -> "Uart_Driver" : Uart_Interrupt_Handler
            activate  "Uart_Driver"
               "Uart_Driver" -> "Application" : Uart Rx interrupt callback
               activate  "Application"
               deactivate  "Application"
            deactivate  "Uart_Driver"
            "Interrupt_Controller_Driver" -> "CPU.Interrupt_Handling" : Disable_Cpu_Interrupting
            activate  "CPU.Interrupt_Handling"
            deactivate  "CPU.Interrupt_Handling"
            "Interrupt_Controller_Driver" -> "GIC 400\nInterrupt Controller" : Write GICC.ICC_EOIR register
            note right
            Notify the interrupt controller that handling
            for the interrupt has been completed.
            (End of Interrupt)
            end note
         deactivate  "Interrupt_Controller_Driver"
      deactivate  "CPU.Interrupt_Handling"

      "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : INTERRUPT_HANDLER_EPILOG
      activate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "CPU.Interrupt_Handling" : Ada_Exit_Interrupt_Context
         activate  "CPU.Interrupt_Handling"
         deactivate  "CPU.Interrupt_Handling"
         "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : restore CPU registers
         activate "interrupt_handling_Asm.S"
         deactivate "interrupt_handling_Asm.S"
         "interrupt_handling_Asm.S" -> "interrupt_handling_Asm.S" : eret
         note right
            Return to interrupted codde
         end note
      deactivate "interrupt_handling_Asm.S"
   deactivate "interrupt_handling_Asm.S"
@enduml